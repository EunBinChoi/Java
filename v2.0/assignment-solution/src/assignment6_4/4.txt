● 하나의 인터페이스 InterfaceA가 있다고 가정하자.
InterfaceA ia = new InterfaceA () (X)
>> 인터페이스는 객체가 될 수 없다.
>> 기본적으로 인터페이스는 객체를 만들기 위한 직접적인 도구가 아니라
객체를 만들 수 있는 클래스를 도와주는 역할이다.
>> 그러나 일반 클래스를 통해 만들어진 객체는 인터페이스 객체 변수에는 들어갈 수 있다.
ex) InterfaceA ia = new ClassA(); (if classA implements InterfaceA)

● 하나의 추상 클래스 AbstractClassA가 있다고 가정하자.
AbstractClassA ac = new AbstractClassA() (X)
>> 추상 클래스는 아직 구현이 덜 되어있는 메서드가 있기 때문에 (구체화가 덜 되었음)
객체를 생성할 수 없다.

● 부모클래스 A를 상속하고 있는 자식클래스 B가 있다고 가정하자. (B is a A)
A a = new B() (O)
>> 자식 클래스로 만들어진 객체는 부모 객체 변수에 살 수 있다. (다형성의 개념)
>> 그러나 부모 클래스로 만들어진 객체는 자식 객체 변수에 살 수 없다.
>> 이렇게 만들어진 이유는 부모 클래스에서 상속받은 공통된 메소드들을 자식 객체들이 가지고 있기 때문에
부모 변수를 통해 자식 객체의 재정의된 메소드나 필드 (부모 클래스로부터 물려받은)를 접근할 수 있도록 하기 위함이다.

● 인터페이스 InterfaceA를 구현하고 있는 구현 클래스 ImplementB가 있다고 가정하자.
InterfaceA a = new ImplementB() (O)
>> 일반 클래스를 통해 만들어진 객체는 인터페이스 객체 변수에는 들어갈 수 있다. (다형성의 개념)
>> 이렇게 만들어진 이유는 공통된 인터페이스를 구현하고 있는 클래스 객체들들을 인터페이스 객체를 통해 접근할 수 있도록 하기 위함이다.

● 클래스 B의 필드로 클래스 A의 객체를 포함하고 있다고 가정하자. (B has a A)
A a = new B() (X)
>> 클래스 B의 필드로 클래스 클래스 A의 객체를 포함하고 한들 클래스 B로 만들어진 객체를 클래스 A 객체 변수에 넣을 수 없음
>> 이런게 가능한 관계는 상속관계나 구현관계 (인터페이스와 해당 인터페이스를 구현하고 있는 클래스) 밖에 없음!